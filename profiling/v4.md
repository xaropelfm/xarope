# V4

## Benchmark

```bash
➜ hyperfine --warmup 3 './target/release/xarope samples/100M.csv'
Benchmark 1: ./target/release/xarope samples/100M.csv
  Time (mean ± σ):     10.293 s ±  0.168 s    [User: 9.742 s, System: 0.525 s]
  Range (min … max):   10.088 s … 10.562 s    10 runs
```

## CPU profiling

```bash
➜ perf record -g --call-graph dwarf ./target/release/xarope samples/100M.csv

➜ perf report --stdio --no-children 2>/dev/null | grep -E "^\s+[0-9]" | head -10
    30.49%  xarope   xarope             [.] csv_core::reader::Reader::read_record
    22.55%  xarope   xarope             [.] xarope::main
    13.38%  xarope   xarope             [.] core::str::converts::from_utf8
     8.37%  xarope   xarope             [.] <rust_decimal::decimal::Decimal as num_traits::cast::ToPrimitive>::to_u64
     5.24%  xarope   xarope             [.] core::str::<impl str>::trim_matches
     5.22%  xarope   xarope             [.] csv::reader::Reader<R>::read_byte_record
     2.86%  xarope   xarope             [.] xarope::decimal_to_u64
     2.31%  xarope   xarope             [.] hashbrown::raw::RawTable<T,A>::reserve_rehash
     1.25%  xarope   xarope             [.] rust_decimal::ops::mul::mul_impl
     0.92%  xarope   [kernel.kallsyms]  [k] _copy_to_iter
```

## Memory profiling

```bash
➜ heaptrack ./target/release/xarope samples/100M.csv

➜ heaptrack_print heaptrack.xarope.*.zst 2>/dev/null | grep -E "^(total|peak|leaked|calls)"
total runtime: 10.49s.
calls to allocation functions: 72 (6/s)
peak heap memory consumption: 1.71G
peak RSS (including heaptrack overhead): 1.68G
total memory leaked: 456B

➜ heaptrack_print heaptrack.xarope.*.zst 2>/dev/null | \                                                          awk '/^[0-9]+ calls/{call=$0; getline; gsub(/^ +/,"",$0); print call " " $0}' | head -10
25 calls to allocation functions with 1.71G peak consumption from _ZN9hashbrown3raw21RawTable$LT$T$C$A$GT$14reserve_rehash17hf56feaa834f5677dE.llvm.13546637831624767653
25 calls with 1.71G peak consumption from: _$LT$std..collections..hash..map..HashMap$LT$K$C$V$C$S$GT$$u20$as$u20$xarope..HashMapInsertUniqueExt$LT$K$C$V$GT$$GT$::insert_unique::h42eaad9e2461dcda
11 calls to allocation functions with 102.42K peak consumption from _ZN9hashbrown3raw21RawTable$LT$T$C$A$GT$14reserve_rehash17hb42c0849740ebe74E.llvm.13546637831624767653
8 calls with 102.42K peak consumption from: _$LT$std..collections..hash..map..HashMap$LT$K$C$V$C$S$GT$$u20$as$u20$xarope..HashMapInsertUniqueExt$LT$K$C$V$GT$$GT$::insert_unique::h631f071a7c88c6e5
1 calls with 0B peak consumption from: xarope::main::ha5e2747e78b9d25f
1 calls with 0B peak consumption from: xarope::main::ha5e2747e78b9d25f
1 calls with 0B peak consumption from: xarope::main::ha5e2747e78b9d25f
6 calls to allocation functions with 304B peak consumption from csv::reader::Reader$LT$R$GT$::read_byte_record::h34739f2288e50842
1 calls with 88B peak consumption from: xarope::main::ha5e2747e78b9d25f
1 calls with 32B peak consumption from: xarope::main::ha5e2747e78b9d25f
```

## Results

This version switched from `StringRecord` iterator to a reusable `ByteRecord` buffer:

- ~6% faster
- 99.99% fewer allocations
- Single `ByteRecord` buffer reused across all rows instead of allocating per-row
